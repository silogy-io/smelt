---
slug: /writing-rules
---

# Extending SMELT

Smelt has two abstractions to represent "work", the Target interface and the Command interface. Semantically, moves through smelt in the following way:

```


        ┌──────────────┐  LOWERED TO        ┌──────────────┐  EXECUTED ON ┌──────────────────┐
        │TARGET        │───────────────────►│COMMAND       │─────────────►│SMELT RUNTIME     │
        │              │                    │              │              │                  │
        └──────────────┘                    └──────────────┘              └──────────────────┘
```

This relationship generalizes to testlists -- a test list, after all, is just a list of targets. Each target is lowered to a set of Commands, and those Commands are executed on the smelt runtime.

To be precise here, the target to command boundary is hard boundary -- the smelt runtime is completely agnostic to targets, and only interfaces with commands

Concretely, a [Target][Target] is any python class that inherits from the target python interface in smelt. End users interact with targets in two ways:

1. Defining targets: end users can define their own targets. Semantically, the definition of a class that inherits from the [Target][Target] interface is directly analogous to a rule in build systems like `bazel` or `buck2`.
2. Instantiating targets: end users create targets in testlists, either yaml based or procedural.

The Target interface is defined at in the [pysmelt.interfaces.target][Target] module.

Each target can create up to three commands:

1. The original command **Required** -- this is the command that should be executed "normally"
2. The @rerun command **Optional** -- this is the command is executed if the original command fails -- this is how smelt impliments automatic re-running of tests. the @rerun command will depend on the @rebuild variants of the dependencies of the original command. the @rerun is command is optional.
3. the @rebuild command **Optional** -- this is the command that is executed if a dependent (that is to say, a downstream command that depends on the original command). This is required because sometimes, when recreating a fail, you will want to rebuild part of the system under test with debug flags. If no @rebuild command is generated by the target, then the @rebuild target will be aliased to the original command

## Command re-running

Lets consider an example to contextualize this:

```yaml
- name: build_simulator
  rule: raw_bash_build
  rule_args:
    cmds:
      - build_release_simulator.sh
    rebuild_cmds:
      - build_debug_simulator.sh

- name: simple_test
  rule: raw_bash
  rule_args:
    cmds:
      - bin/release_simulator --seed 1000
    rerun_cmds:
      - bin/debug_simulator --seed 1000
    deps:
      - build_simulator
```

In the happy path, if we run the `simple_test` test, what will happen is:

1. The release simulator will be built
2. The `simple_test` will execute successfully
3. (Optional) know peace -- the system under test is functionally correct

But `simple_test` _will_ fail occasionally -- what happens then?

1. The simulator will be built
2. `simple_test` fails
3. The smelt runtime tries to execute the `simple_test@rerun` command
   a. `simple_test@rerun` has an explicit dependency on `build_simulator@rebuild` -- so first `build_simulator@rebuild`, the simulator is rebuilt in debug mode
   b. `simple_test@rerun` has all of its dependencies met -- now it will execute.

If we visualize the graph of commands that is generated from the test list above, it will look like the following:

```

  ┌────────────────┐
  │build_simulator │                         ┌────────────────────────┐
  │                │                         │build_simulator@rebuild │
  └────────────────┘                         │                        │
         ▲                                   └────────────────────────┘
         │depends on                               ▲
         │                                         │
 ┌──────────────────┐                              │depends on
 │simple_test       │                              │
 │                  │                              │
 └──────────────────┘                              │
               ▲                                   │
               │  depends on the failure of  ┌──────────────────┐
               └─────────────────────────────│simple_test@rerun │
                                             │                  │
                                             └──────────────────┘


```

## Defining a new target

End users can define their own smelt targets in their own repo by defining classes that inherit from the `Target` class in the `${SMELT_ROOT}/smelt_rules` directory.

{/* prettier-ignore-start */}
[Command]:https://github.com/silogy-io/smelt/blob/dev/py-smelt/pysmelt/interfaces/command.py
[Target]: https://github.com/silogy-io/smelt/blob/dev/py-smelt/pysmelt/interfaces/target.py
[smelt_root]: google.com
[bazel]: https://bazel.build
[buck2]: https://buck2.build

{/* prettier-ignore-end */}
